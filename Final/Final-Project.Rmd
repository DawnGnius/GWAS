---
title: "Final Project"
author: "Liu Huihang"
date: "12/7/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Introduction & Definition

### eQTL

Genetical genomics experiments have now been routinely conducted to measure both the genetic markers and gene expression data on the same subjects. The gene expression levels are often treated as quantitative traits and are subject to standard genetic analysis in order to identify the gene expression quantitative loci (eQTL). 


### Yeast

酵母菌一共有 16 条染色体, 全部记录在数据中. 

### Genetic Markers. 
A genotype indicates the genetic state of the DNA in an organism. 
It is a theoretical construct describing a genetic situation that explains the observed properties (phenotype, see below) of a strain. 



## Data Preparation

The **yeast** dataset is a subset of the widely studied yeast expression dataset comprising of $112$ *F1* segregants from a cross between *BY4716* and *RM11-1a* strains of Saccharomyces Cerevisiae.

The original dataset consists of expression values reported as $log_2(\text{sample} / \text{BY reference})$ for $7085$ genes. 


The data can be accessed in Gene Expression Omnibus (GEO) by accession number (GSE1990). 

```{r, message=FALSE, eval=FALSE, include=FALSE}
# Original data
# https://warwick.ac.uk/fac/sci/moac/people/students/peter_cock/r/geo/
# dat <- read.csv("GSE1990_series_matrix.txt", header=TRUE, sep = "\t")

library(Biobase)
library(GEOquery)

# gse1990 <- getGEO('GSE1990', destdir=".")
# load series and platform data from GEO

gset <- getGEO("GSE1990", GSEMatrix =TRUE, getGPL=FALSE, destdir="./Data")
if (length(gset) > 1) idx <- grep("GPL118", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]

# set parameters and draw the plot

# dev.new(width=4+dim(gset)[[2]]/5, height=6)   # unsupported in rmd
par(mar=c(2+round(max(nchar(sampleNames(gset)))/2), 4, 2, 1))
title <- paste("GSE1990", '/', annotation(gset), " selected samples", sep ='')
BiocGenerics::boxplot(exprs(gset), boxwex=0.7, notch=T, main=title, outline=FALSE, las=2, plot = TRUE)
```

Value distribution allows you to calculate and view the distribution of the values for the Samples you have selected. 
Values are the original submitter-supplied data upon which GEO2R calculations are performed. 
Viewing the distribution is important for determining if your selected Samples are suitable for comparison; see Limitations and caveats for more information. 
Generally, median-centered values are indicative that the data are normalized and cross-comparable. 

### Data Preprocessing

In **SOFAR**, the data is finally reduced to the size of $n=112, p=605, q=54$. 

In **geneNetBP**, $n=112, p=12, q=38$. 
Thus the final dataset is a data frame of $112$ observations (genotype) of $12$ variables (SNP markers) and normalized gene expression of $38$ variables (genes). 
The gene expression values are discretized around the median and have two states, $1$ (above or equal to median) and $-1$ (below median). 
There are two genotype states: $1$ or $2$. 

```{r, warning=FALSE, message=FALSE, eval=FALSE, include=FALSE}
# Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE1990
# geneNetBP: https://cran.r-project.org/web/packages/geneNetBP/geneNetBP.pdf
# trigger: https://bioconductor.org/packages/release/bioc/vignettes/trigger/inst/doc/trigger.pdf

library(geneNetBP)    # for data(yeast)

data(yeast)

head(yeast)

# fit.dbn(yeast[,1:12],yeast[,13:50])
```

In **trigger**, *marker*: A $3244$ × $112$ genotype matrix; *exp*: A $6216$ × $112$ gene expression matrix

接下来使用 trigger 数据, 进行预处理. 降低 $X$ 与 $Y$ 的维度.
```{r, message=FALSE}
rm(list=ls())
DEBUG <- FALSE

# load data from trigger package or tmp.RData
if (FALSE){
  library(trigger)
  data(yeast)
} else{
  load('tmp.RData')
}

library(stats)

marker <- yeast$marker
exp <- yeast$exp
```

Distance clustering, d <= 1

```{r}
# hclust
out.dist <- dist(marker, method="manhattan")
hc1.complete <- hclust(dist(marker, method="manhattan"), method="complete") # complete method using the max distance within a group
out.id <- cutree(hc1.complete, h=1)                                         # h is the maximum distance to be cut
if (DEBUG) print(max(out.id))
if (DEBUG){
  for (ii in 1:max(out.id)) {
    tmp <- marker[which(out.id==ii),]                                         
    if (is.matrix(tmp)) {
      d <- matrix(rep(1,dim(tmp)[1]),ncol=1) %*% tmp[1,] - tmp
      d.col <- colSums(abs(d))
      if (length(which(d.col != 0)) > 1){
        cat("some thing wrong at ", ii, "ther are", length(which(d.col != 0)), "diffs \n")
      }
    }
  }
}
```

We combined the markers into `r max(out.id)` blocks where the markers within a block differed by at most $1$ sample. 
We select the most repeated marker from each block as the representative marker. 

中文: 将每组的众数取出来作为该组的代表. 生成新的 marker: X. 
```{r}
count <- numeric(max(out.id))
for (ii in 1:max(out.id)) {
  tmp <- marker[which(out.id==ii),]
  if (!is.matrix(tmp)) {
    count[ii] <- which(out.id == ii)
    next
  }
  tmp.unique <- unique(tmp)
  if (dim(tmp.unique)[1] == 1){
    count[ii] <- which(out.id == ii)[1]
    next
  }
  tmp.count <- numeric(2)
  tmp.rec <- numeric(length(which(out.id == ii)))
  for (jj in 1:length(which(out.id == ii))) {
    want <- marker[which(out.id == ii)[jj],]
    tmp.idx <- ifelse(sum(abs(want - tmp.unique[2,])), 1, 2) 
    tmp.count[tmp.idx] <- tmp.count[tmp.idx] + 1
    tmp.rec[jj] <- tmp.idx
  }
  tmp.mostfreq <- which.max(table(tmp.rec))[1]
  count[ii] <- which(out.id == ii)[which(tmp.rec == tmp.mostfreq)[1]]
}

X <- t(marker[count,])
```

Next, I am going to reduce the dimension of $Y$. 
```{r}
# From The yeast MAPK pathway from the KEGG database http://www.genome.jp/kegg/pathway/sce/sce04011.html
MAPK.pathway.name <- c('MATALPHA1', 'MATALPHA2', 'STE2', 'STE3', 'GPA1', 'STE4', 'STE18', 'CDC42', 'CDC24', 'BEM1', 'STE20', 'BNI1', 'STE11', 'STE5', 'STE7', 'FUS3', 'MSG5', 'STE12', 'DIG1', 'DIG2', 'FAR1', 'MCM1', 'FUS1', 'WSC4', 'WSC2', 'WSC3', 'MID2', 'RHO1', 'FKS1', 'PKC1', 'BCK1', 'MKK1', 'MKK2', 'SLT2', 'MLP2', 'RLM1', 'SWI4', 'SWI6', 'FKS3', 'SHO1', 'SLN1', 'YPD1', 'SSK1', 'SSK2', 'PBS2', 'HOG1', 'MSN2', 'MSN4', 'GLO1', 'CTT1', 'RAS2', 'KSS1', 'TEC1')
# CHANGE: WSC1->WSC4; FKS2->FKS3

idx.exp <- sapply(MAPK.pathway.name, function(x) which(rownames(exp) == x))
Y <- t(exp[idx.exp,])


if (!DEBUG){
  rm("idx.exp", "MAPK.pathway.name")
}
if (!DEBUG){
  rm("count", "ii", "jj", "out.dist", "out.id", "tmp.count", "tmp.idx", "tmp.mostfreq", "tmp.rec", "want", "hc1.complete", "tmp", "tmp.unique")
}
```

Finally, we obtain the processed data:  $X \in \mathbb{R}^{112\times 949}$, $Y \in \mathbb{R}^{112\times 53}$. 



## Statistical Analysis

Using some statistical methods to analysis the data. 

Repeat the simulation study of SOFAR. 

### Simple data analysis:

1. Estimate the covariance matrix of X

2. The correlation between X and Y

```{r}
sis1 <- t(X) %*% Y[,1]
```

### SOFAR
```{r, message=FALSE, eval=FALSE}
library(rrpack)
# source('./SOFAR/rrpack/R/sofar.R')
# source('./SOFAR/rrpack/R/RcppExports.R')
# source('./SOFAR/rrpack/R/penreg.R')

res.sofar <- cv.sofar(Y, X, nrank=3, ic.type="GCV", control=list(lam.min.factor=5e-7, lam.max.factor=1e-4, nlam=100, methodA="lasso", methodB="lasso"), DEBUG=TRUE)
# summary(res.sofar)
# note: lam.min.factor and lam.max.factor are lower and upper factors multiplied by lam.max=28176.lam.max is a large number. So lam.min.factor should be # cv.sofar use GIC rather than CV
nonzero.u <- which(res.sofar$U != 0)

U1 <- rowSums(res.sofar$U)
length(which(U1 != 0))

which(res.sofar$U == 0)

heatmap(Y)
heatmap(X%*%res.sofar$U%*%diag(res.sofar$D)%*%t(res.sofar$V))
```

```{r, warning=FALSE}
# load the packages and codes
library(rrpack)
# source("./heatmap.3.r")

# Estimation
res.sofar <- sofar(Y, X, nrank=3, ic.type="GIC", control=list(lamA=0.2, lamB=0.08, lamD=0.1))

# check for sparsity of U
u.rowsums <- rowSums(abs(res.sofar$U))
nonzero.u.hat <- length(which(u.rowsums != 0))
# check for sparsity of V
v.rowsums <- rowSums(abs(res.sofar$V))
nonzero.v.hat <- length(which(v.rowsums != 0))
# print the result
cat("There are", nonzero.u.hat, "non-zero rows in the estimation of U, and", nonzero.v.hat, "non-zero rows in the estimation of V.")


# # heatmap of Y
# # layout(c(1, 2))
heatmap(Y, Colv = NA, Rowv=NA, col=topo.colors(256))
heatmap(X %*% res.sofar$U %*% diag(res.sofar$D) %*% t(res.sofar$V), Colv = NA, Rowv=NA, col=topo.colors(256))


# plot sofar
# par(mfrow=c(1,3))
# layout(matrix(c(1,2,3), 1, 3, byrow = TRUE))
plot(res.sofar, layer=1, xlab="latent predictor ", ylab="latent response ")
plot(res.sofar, layer=2, xlim=c(-3,0), ylim=c(-10,0))
plot(res.sofar, layer=3, xlim=c(-3,0), ylim=c(-10,0))
```

There is a big problem.
I cannot draw a multi-plot using 'par' or 'layout' in a normal way. 
Even I can not change the range of X-axis or Y-axis. 
I want to get two similar figures in SOFAR paper. 